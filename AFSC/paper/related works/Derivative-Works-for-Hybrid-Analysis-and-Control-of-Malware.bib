@article{a466428f79113489dbc68111c2881acfb77325de,
title = {Towards Paving the Way for Large-Scale Windows Malware Analysis: Generic Binary Unpacking with Orders-of-Magnitude Performance Boost},
year = {2018},
url = {https://www.semanticscholar.org/paper/a466428f79113489dbc68111c2881acfb77325de},
abstract = {Binary packing, encoding binary code prior to execution and decoding them at run time, is the most common obfuscation adopted by malware authors to camouflage malicious code. Especially, most packers recover the original code by going through a set of "written-then-executed" layers, which renders determining the end of the unpacking increasingly difficult. Many generic binary unpacking approaches have been proposed to extract packed binaries without the prior knowledge of packers. However, the high runtime overhead and lack of anti-analysis resistance have severely limited their adoptions. Over the past two decades, packed malware is always a veritable challenge to anti-malware landscape. This paper revisits the long-standing binary unpacking problem from a new angle: packers consistently obfuscate the standard use of API calls. Our in-depth study on an enormous variety of Windows malware packers at present leads to a common property: malware's Import Address Table (IAT), which acts as a lookup table for dynamically linked API calls, is typically erased by packers for further obfuscation; and then unpacking routine, like a custom dynamic loader, will reconstruct IAT before original code resumes execution. During a packed malware execution, if an API is invoked through looking up a rebuilt IAT, it indicates that the original payload has been restored. This insight motivates us to design an efficient unpacking approach, called BinUnpack. Compared to the previous methods that suffer from multiple "written-then-executed" unpacking layers, BinUnpack is free from tedious memory access monitoring, and therefore it introduces very small runtime overhead. To defeat a variety of ever-evolving evasion tricks, we design BinUnpack's API monitor module via a novel kernel-level DLL hijacking technique. We have evaluated BinUnpack's efficacy extensively with more than 238K packed malware and multiple Windows utilities. BinUnpack's success rate is significantly better than that of existing tools with several orders of magnitude performance boost. Our study demonstrates that BinUnpack can be applied to speeding up large-scale malware analysis.},
author = {Binlin Cheng and Jiang Ming and Jianming Fu and Guojun Peng and Ting Chen and Xiaosong Zhang and J. Marion},
journal = {Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security},
volume = {},
pages = {},
doi = {10.1145/3243734.3243771},
}

@article{f37e00cf4c5e7466f515cf3650c238edfd834a65,
title = {Obfuscation-Resilient Executable Payload Extraction From Packed Malware},
year = {2021},
url = {https://www.semanticscholar.org/paper/f37e00cf4c5e7466f515cf3650c238edfd834a65},
abstract = {Over the past two decades, packed malware is always a veritable challenge to security analysts. Not only is determining the end of the unpacking increasingly difficult, but also advanced packers embed a variety of anti-analysis tricks to impede reverse engineering. As malware’s APIs provide rich information about malicious behavior, one common anti-analysis strategy is API obfuscation, which removes the metadata of imported APIs from malware’s PE header and complicates API name resolution from API callsites. In this way, even when security analysts obtain the unpacked code, a disassembler still fails to recognize imported API names, and the unpacked code cannot be successfully executed. Recently, generic binary unpacking has made breakthrough progress with noticeable performance improvement. However, reconstructing unpacked code’s import tables, which is vital for further malware static/dynamic analyses, has largely been overlooked. Existing approaches are far from mature: they either can be easily evaded by various API obfuscation schemes (e.g., stolen code), or suffer from incomplete API coverage. In this paper, we aim to achieve the ultimate goal of Windows malware unpacking: recovering an executable malware program from the packed and obfuscated binary code. Based on the process memory when the original entry point (OEP) is reached, we develop a hardware-assisted tool, API-Xray, to reconstruct import tables. Import table reconstruction is challenging enough in its own right. Our core technique, API Micro Execution, explores all possible API callsites and executes them without knowing API argument values. At the same time, we take advantage of hardware tracing via Intel Branch Trace Store and NX bit to resolve API names and finally rebuild import tables. Compared with the previous work, API-Xray has a better resistance against various API ∗Both authors contributed equally to the paper. †(1) Key Laboratory of Aerospace Information Security and Trust Computing, Ministry of Education; (2) School of Cyber Science and Engineering, Wuhan University. ‡Corresponding authors: jiang.ming@uta.edu. obfuscation schemes and more coverage on resolved Windows API names. Since July 2019, we have tested API-Xray in practice to assist security professionals in malware analysis: we have successfully rebuilt 155,811 executable malware programs and substantially improved the detection rate for 7,514 unknown or new malware variants.},
author = {Binlin Cheng and Jiang Ming and E. A. Leal and Haotian Zhang and Jianming Fu and Guojun Peng and J. Marion},
}

@article{f914128ce924cee7eb3bb970cecabed07e95f054,
title = {The Effect of Code Obfuscation on Authorship Attribution of Binary Computer Files},
year = {2017},
url = {https://www.semanticscholar.org/paper/f914128ce924cee7eb3bb970cecabed07e95f054},
abstract = {},
author = {Steven Hendrikse},
}

@article{cbaeac53940b05dde80471dfc6033377a71fab65,
title = {Protecting Software through Obfuscation},
year = {2016},
url = {https://www.semanticscholar.org/paper/cbaeac53940b05dde80471dfc6033377a71fab65},
abstract = {Software obfuscation has always been a controversially discussed research area. While theoretical results indicate that provably secure obfuscation in general is impossible, its widespread application in malware and commercial software shows that it is nevertheless popular in practice. Still, it remains largely unexplored to what extent today’s software obfuscations keep up with state-of-the-art code analysis and where we stand in the arms race between software developers and code analysts. The main goal of this survey is to analyze the effectiveness of different classes of software obfuscation against the continuously improving deobfuscation techniques and off-the-shelf code analysis tools. The answer very much depends on the goals of the analyst and the available resources. On the one hand, many forms of lightweight static analysis have difficulties with even basic obfuscation schemes, which explains the unbroken popularity of obfuscation among malware writers. On the other hand, more expensive analysis techniques, in particular when used interactively by a human analyst, can easily defeat many obfuscations. As a result, software obfuscation for the purpose of intellectual property protection remains highly challenging.},
author = {S. Schrittwieser and S. Katzenbeisser and Johannes Kinder and Georg Merzdovnik and E. Weippl},
journal = {ACM Computing Surveys (CSUR)},
volume = {49},
pages = {1 - 37},
doi = {10.1145/2886012},
}

@article{be0f5d8efcf6e5102d3db719a9e10ebab22b3bf9,
title = {Hybrid analysis and control of malicious code},
year = {2012},
url = {https://www.semanticscholar.org/paper/be0f5d8efcf6e5102d3db719a9e10ebab22b3bf9},
abstract = {State of the art analysis techniques for malicious executables lag significantly behind their counterparts for compiler-generated executables. This difference exists because 90% of malicious software (also known as malware) actively resists analysis. In particular, most malware resists static attempts to recover structural information from its binary code, and resists dynamic attempts to observe and modify its code. 
In this dissertation, we develop static and dynamic techniques and combine them in a hybrid algorithm that preserves the respective strengths of these techniques while mitigating their weaknesses. In particular, we build structural analyses with static parsing techniques that can disassemble arbitrarily obfuscated binary code with high accuracy, and recover the structure of that code in terms of functions, loops, and basic blocks. We develop dynamic techniques to identify transitions into statically unreachable code and respond to malware that overwrites its code. These dynamic techniques remove overwritten and unreachable code from our analysis and trigger additional parsing at entry points into un-analyzed code, before this code executes. Our stealthy instrumentation techniques leverage our structural analysis to stealthily and efficiently instrument binary code that resists modification. These instrumentation techniques hide the modifications they make to the binary code, and the additional space that they allocate in the program's address space to hold instrumentation. 
We demonstrate the utility of our techniques by adapting the Dyninst 7.0 binary analysis and instrumentation tool so that its users can analyze defensive malware code in exactly the same way that they analyze non-defensive binaries. We also build customizable malware analysis factories that perform batch-processing of malware binaries in an isolated environment, to help security companies efficiently process the tens of thousands of new malware samples that they receive each day. Finally, we use our analysis factory to study the most prevalent defensive techniques used by malware binaries. We thereby provide a snapshot of the obfuscation techniques that we have seen to date, and demonstrate that our techniques allow us to analyze and instrument highly defensive binary code.},
author = {B. Miller and Kevin A. Roundy},
}

@article{974f362d3fcabfba7befbb7cba9d8027d5942f35,
title = {Binary-code obfuscations in prevalent packer tools},
year = {2013},
url = {https://www.semanticscholar.org/paper/974f362d3fcabfba7befbb7cba9d8027d5942f35},
abstract = {The first steps in analyzing defensive malware are understanding what obfuscations are present in real-world malware binaries, how these obfuscations hinder analysis, and how they can be overcome. While some obfuscations have been reported independently, this survey consolidates the discussion while adding substantial depth and breadth to it. This survey also quantifies the relative prevalence of these obfuscations by using the Dyninst binary analysis and instrumentation tool that was recently extended for defensive malware analysis. The goal of this survey is to encourage analysts to focus on resolving the obfuscations that are most prevalent in real-world malware.},
author = {Kevin A. Roundy and B. Miller},
journal = {ACM Comput. Surv.},
volume = {46},
pages = {4:1-4:32},
doi = {10.1145/2522968.2522972},
}

@article{6bbd585a24d95171222965b20fc1a78ce8faa271,
title = {RAMBO: Run-Time Packer Analysis with Multiple Branch Observation},
year = {2016},
url = {https://www.semanticscholar.org/paper/6bbd585a24d95171222965b20fc1a78ce8faa271},
abstract = {Run-time packing is a technique employed by malware authors in order to conceal e.g., encrypt malicious code and recover it at run-time. In particular, some run-time packers only decrypt individual regions of code on demand, re-encrypting them again when they are not running. This technique is known as shifting decode frames and it can greatly complicate malware analysis. The first solution that comes to mind to analyze these samples is to apply multi-path exploration to trigger the unpacking of all the code regions. Unfortunately, multi-path exploration is known to have several limitations, such as its limited scalability for the analysis of real-world binaries. In this paper, we propose a set of domain-specific optimizations and heuristics to guide multi-path exploration and improve its efficiency and reliability for unpacking binaries protected with shifting decode frames.},
author = {Xabier Ugarte-Pedrero and D. Balzarotti and I. Santos and P. G. Bringas},
doi = {10.1007/978-3-319-40667-1_10},
}

@article{5db680f254053a515f0dd1eb811fd36746fc6fa9,
title = {A Survey On Automated Dynamic Malware Analysis Evasion and Counter-Evasion: PC, Mobile, and Web},
year = {2017},
url = {https://www.semanticscholar.org/paper/5db680f254053a515f0dd1eb811fd36746fc6fa9},
abstract = {Automated dynamic malware analysis systems are important in combating the proliferation of modern malware. Unfortunately, malware can often easily detect and evade these systems. Competition between malware authors and analysis system developers has pushed each to continually evolve their tactics for countering the other.
 In this paper we systematically review i) "fingerprint"-based evasion techniques against automated dynamic malware analysis systems for PC, mobile, and web, ii) evasion detection, iii) evasion mitigation, and iv) offensive and defensive evasion case studies. We also discuss difficulties in experimental evaluation, highlight future directions in offensive and defensive research, and briefly survey related topics in anti-analysis.},
author = {Alexei Bulazel and B. Yener},
doi = {10.1145/3150376.3150378},
}

@article{1fe696eebdfdfc629fd662eb61da173d7e676be1,
title = {When Malware is Packin' Heat; Limits of Machine Learning Classifiers Based on Static Analysis Features},
year = {2020},
url = {https://www.semanticscholar.org/paper/1fe696eebdfdfc629fd662eb61da173d7e676be1},
abstract = {Machine learning techniques are widely used in addition to signatures and heuristics to increase the detection rate of anti-malware software, as they automate the creation of detection models, making it possible to handle an ever-increasing number of new malware samples. In order to foil the analysis of anti-malware systems and evade detection, malware uses packing and other forms of obfuscation. However, few realize that benign applications use packing and obfuscation as well, to protect intellectual property and prevent license abuse. In this paper, we study how machine learning based on static analysis features operates on packed samples. Malware researchers have often assumed that packing would prevent machine learning techniques from building effective classifiers. However, both industry and academia have published results that show that machine-learning-based classifiers can achieve good detection rates, leading many experts to think that classifiers are simply detecting the fact that a sample is packed, as packing is more prevalent in malicious samples. We show that, different from what is commonly assumed, packers do preserve some information when packing programs that is “useful” for malware classification. However, this information does not necessarily capture the sample’s behavior. We demonstrate that the signals extracted from packed executables are not rich enough for machine-learning-based models to (1) generalize their knowledge to operate on unseen packers, and (2) be robust against adversarial examples. We also show that a naı̈ve application of machine learning techniques results in a substantial number of false positives, which, in turn, might have resulted in incorrect labeling of ground-truth data used in past work.},
author = {H. Aghakhani and Fabio Gritti and Francesco Mecca and Martina Lindorfer and Stefano Ortolani and D. Balzarotti and Giovanni Vigna and C. Kruegel},
doi = {10.14722/ndss.2020.24310},
}

@article{e396249ffcdef50c61222b1118b8a7138262eb32,
title = {SoK: Deep Packer Inspection: A Longitudinal Study of the Complexity of Run-Time Packers},
year = {2015},
url = {https://www.semanticscholar.org/paper/e396249ffcdef50c61222b1118b8a7138262eb32},
abstract = {Run-time packers are often used by malware-writers to obfuscate their code and hinder static analysis. The packer problem has been widely studied, and several solutions have been proposed in order to generically unpack protected binaries. Nevertheless, these solutions commonly rely on a number of assumptions that may not necessarily reflect the reality of the packers used in the wild. Moreover, previous solutions fail to provide useful information about the structure of the packer or its complexity. In this paper, we describe a framework for packer analysis and we propose a taxonomy to measure the runtime complexity of packers. We evaluated our dynamic analysis system on two datasets, composed of both off-the-shelf packers and custom packed binaries. Based on the results of our experiments, we present several statistics about the packers complexity and their evolution over time.},
author = {Xabier Ugarte-Pedrero and D. Balzarotti and I. Santos and P. G. Bringas},
journal = {2015 IEEE Symposium on Security and Privacy},
volume = {},
pages = {659-673},
doi = {10.1109/SP.2015.46},
}
