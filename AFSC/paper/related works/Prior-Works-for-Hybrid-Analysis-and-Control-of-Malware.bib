@article{2b567737b5567f8e9f13b17f4f3583c6eea1e212,
title = {Renovo: a hidden code extractor for packed executables},
year = {2007},
url = {https://www.semanticscholar.org/paper/2b567737b5567f8e9f13b17f4f3583c6eea1e212},
abstract = {As reverse engineering becomes a prevalent technique to analyze malware, malware writers leverage various anti-reverse engineering techniques to hide their code. One technique commonly used is code packing as packed executables hinder code analysis. While this problem has been previously researched, the existing solutions are either unable to handle novel samples, or vulnerable to various evasion techniques. In this paper, we propose a fully dynamic approach that captures an intrinsic nature of hidden code execution that the original code should be present in memory and executed at some point at run-time. Thus, this approach monitors program execution and memory writes at run-time, determines if the code under execution is newly generated, and then extracts the hidden code of the executable. To demonstrate its effectiveness, we implement a system, Renovo, and evaluate it with a large number of real-world malware samples. The experiments show that Renovo is accurate compared to previous work, yet practical in terms of performance},
author = {M. Kang and Pongsin Poosankam and Heng Yin},
doi = {10.1145/1314389.1314399},
}

@article{6931534745883ec27abc8268ed40c0976c6d22c3,
title = {OmniUnpack: Fast, Generic, and Safe Unpacking of Malware},
year = {2007},
url = {https://www.semanticscholar.org/paper/6931534745883ec27abc8268ed40c0976c6d22c3},
abstract = {Malicious software (or malware) has become a growing threat as malware writers have learned that signature- based detectors can be easily evaded by "packing" the malicious payload in layers of compression or encryption. State-of-the-art malware detectors have adopted both static and dynamic techniques to recover the pay- load of packed malware, but unfortunately such techniques are highly ineffective. In this paper we propose a new technique, called OmniUnpack, to monitor the execution of a program in real-time and to detect when the program has removed the various layers of packing. OmniUnpack aids malware detection by directly providing to the detector the unpacked malicious payload. Experimental results demonstrate the effectiveness of our approach. OmniUnpack is able to deal with both known and unknown packing algorithms and introduces a low overhead (at most 11% for packed benign programs).},
author = {L. Martignoni and Mihai Christodorescu and S. Jha},
journal = {Twenty-Third Annual Computer Security Applications Conference (ACSAC 2007)},
volume = {},
pages = {431-441},
doi = {10.1109/ACSAC.2007.15},
}

@article{db9f9abd46ed75e727be2283a038ccc232feb688,
title = {PolyUnpack: Automating the Hidden-Code Extraction of Unpack-Executing Malware},
year = {2006},
url = {https://www.semanticscholar.org/paper/db9f9abd46ed75e727be2283a038ccc232feb688},
abstract = {Modern malware often hide the malicious portion of their program code by making it appear as data at compile-time and transforming it back into executable code at runtime. This obfuscation technique poses obstacles to researchers who want to understand the malicious behavior of new or unknown malware and to practitioners who want to create models of detection and methods of recovery. In this paper we propose a technique for automating the process of extracting the hidden-code bodies of this class of malware. Our approach is based on the observation that sequences of packed or hidden code in a malware instance can be made self-identifying when its runtime execution is checked against its static code model. In deriving our technique, we formally define the unpack-executing behavior that such malware exhibits and devise an algorithm for identifying and extracting its hidden-code. We also provide details of the implementation and evaluation of our extraction technique; the results from our experiments on several thousand malware binaries show our approach can be used to significantly reduce the time required to analyze such malware, and to improve the performance of malware detection tools.},
author = {P. Royal and Mitch Halpin and D. Dagon and R. Edmonds and Wenke Lee},
journal = {2006 22nd Annual Computer Security Applications Conference (ACSAC'06)},
volume = {},
pages = {289-300},
doi = {10.1109/ACSAC.2006.38},
}

@article{969142267960a5de8fb56aab976880ed6b921108,
title = {Ether: malware analysis via hardware virtualization extensions},
year = {2008},
url = {https://www.semanticscholar.org/paper/969142267960a5de8fb56aab976880ed6b921108},
abstract = {Malware has become the centerpiece of most security threats on the Internet. Malware analysis is an essential technology that extracts the runtime behavior of malware, and supplies signatures to detection systems and provides evidence for recovery and cleanup. The focal point in the malware analysis battle is how to detect versus how to hide a malware analyzer from malware during runtime. State-of-the-art analyzers reside in or emulate part of the guest operating system and its underlying hardware, making them easy to detect and evade. In this paper, we propose a transparent and external approach to malware analysis, which is motivated by the intuition that for a malware analyzer to be transparent, it must not induce any side-effects that are unconditionally detectable by malware. Our analyzer, Ether, is based on a novel application of hardware virtualization extensions such as Intel VT, and resides completely outside of the target OS environment. Thus, there are no in-guest software components vulnerable to detection, and there are no shortcomings that arise from incomplete or inaccurate system
 emulation. Our experiments are based on our study of obfuscation techniques used to create 25,000 recent malware samples. The results show that Ether remains transparent and defeats the obfuscation tools that evade existing approaches.},
author = {Artem Dinaburg and P. Royal and Monirul I. Sharif and Wenke Lee},
doi = {10.1145/1455770.1455779},
}

@article{4dcd5ca0ba7aac6c08f8b657e5b889a908c78ea1,
title = {Exploring Multiple Execution Paths for Malware Analysis},
year = {2007},
url = {https://www.semanticscholar.org/paper/4dcd5ca0ba7aac6c08f8b657e5b889a908c78ea1},
abstract = {Malicious code (or Malware) is defined as software that fulfills the deliberately harmful intent of an attacker. Malware analysis is the process of determining the behavior and purpose of a given Malware sample (such as a virus, worm, or Trojan horse). This process is a necessary step to be able to develop effective detection techniques and removal tools. Currently, Malware analysis is mostly a manual process that is tedious and time-intensive. To mitigate this problem, a number of analysis tools have been proposed that automatically extract the behavior of an unknown program by executing it in a restricted environment and recording the operating system calls that are invoked. The problem of dynamic analysis tools is that only a single program execution is observed. Unfortunately, however, it is possible that certain malicious actions are only triggered under specific circumstances (e.g., on a particular day, when a certain file is present, or when a certain command is received). In this paper, we propose a system that allows us to explore multiple execution paths and identify malicious actions that are executed only when certain conditions are met. This enables us to automatically extract a more complete view of the program under analysis and identify under which circumstances suspicious actions are carried out. Our experimental results demonstrate that many Malware samples show different behavior depending on input read from the environment. Thus, by exploring multiple execution paths, we can obtain a more complete picture of their actions.},
author = {Andreas Moser and Christopher Krügel and E. Kirda},
journal = {2007 IEEE Symposium on Security and Privacy (SP '07)},
volume = {},
pages = {231-245},
doi = {10.1109/SP.2007.17},
}

@article{6de5a2f262cfeb6327af46e2066959a2320ffc9f,
title = {Pin: building customized program analysis tools with dynamic instrumentation},
year = {2005},
url = {https://www.semanticscholar.org/paper/6de5a2f262cfeb6327af46e2066959a2320ffc9f},
abstract = {Robust and powerful software instrumentation tools are essential for program analysis tasks such as profiling, performance evaluation, and bug detection. To meet this need, we have developed a new instrumentation system called Pin. Our goals are to provide easy-to-use, portable, transparent, and efficient instrumentation. Instrumentation tools (called Pintools) are written in C/C++ using Pin's rich API. Pin follows the model of ATOM, allowing the tool writer to analyze an application at the instruction level without the need for detailed knowledge of the underlying instruction set. The API is designed to be architecture independent whenever possible, making Pintools source compatible across different architectures. However, a Pintool can access architecture-specific details when necessary. Instrumentation with Pin is mostly transparent as the application and Pintool observe the application's original, uninstrumented behavior. Pin uses dynamic compilation to instrument executables while they are running. For efficiency, Pin uses several techniques, including inlining, register re-allocation, liveness analysis, and instruction scheduling to optimize instrumentation. This fully automated approach delivers significantly better instrumentation performance than similar tools. For example, Pin is 3.3x faster than Valgrind and 2x faster than DynamoRIO for basic-block counting. To illustrate Pin's versatility, we describe two Pintools in daily use to analyze production software. Pin is publicly available for Linux platforms on four architectures: IA32 (32-bit x86), EM64T (64-bit x86), Itanium®, and ARM. In the ten months since Pin 2 was released in July 2004, there have been over 3000 downloads from its website.},
author = {C. Luk and R. Cohn and R. Muth and H. Patil and A. Klauser and G. Lowney and S. Wallace and V. Reddi and K. Hazelwood},
doi = {10.1145/1065010.1065034},
}

@article{76f8691b17489c901683595d721866c3e60ff308,
title = {A Study of the Packer Problem and Its Solutions},
year = {2008},
url = {https://www.semanticscholar.org/paper/76f8691b17489c901683595d721866c3e60ff308},
abstract = {An increasing percentage of malware programs distributed in the wild are packed by packers, which are programs that transform an input binary's appearance without affecting its execution semantics, to create new malware variants that can evade signature-based malware detection tools. This paper reports the results of a comprehensive study of the extent of the packer problem based on data collected at Symantec and the effectiveness of existing solutions to this problem. Then the paper presents a generic unpacking solution called Justin (Just-In-Time AV scanning), which is designed to detect the end of unpacking of a packed binary's run and invoke AV scanning against the process image at that time. For accurate end-to-unpacking detection, Justin incorporates the following heuristics: Dirty Page Execution, Unpacker Memory Avoidance, Stack Pointer Check and Command-Line Argument Access. Empirical testing shows that when compared with SymPack, which contains a set of manually created unpackers for a collection of selective packers, Justin's effectiveness is comparable to SymPack for those binaries packed by these supported packers, and is much better than SymPack for binaries packed by those that SymPack does not support.},
author = {F. Guo and Peter Ferrie and T. Chiueh},
doi = {10.1007/978-3-540-87403-4_6},
}

@article{93e591fe251b3eacba89a3ff4a8c503ddc54c617,
title = {QEMU, a Fast and Portable Dynamic Translator},
year = {2005},
url = {https://www.semanticscholar.org/paper/93e591fe251b3eacba89a3ff4a8c503ddc54c617},
abstract = {We present the internals of QEMU, a fast machine emulator using an original portable dynamic translator. It emulates several CPUs (x86, PowerPC, ARM and Sparc) on several hosts (x86, PowerPC, ARM, Sparc, Alpha and MIPS). QEMU supports full system emulation in which a complete and unmodified operating system is run in a virtual machine and Linux user mode emulation where a Linux process compiled for one target CPU can be run on another CPU.},
author = {Fabrice Bellard},
}

@article{c3046d3036662b3dea5ac8b7edd86cbef309d587,
title = {Toward Automated Dynamic Malware Analysis Using CWSandbox},
year = {2007},
url = {https://www.semanticscholar.org/paper/c3046d3036662b3dea5ac8b7edd86cbef309d587},
abstract = {Malware is notoriously difficult to combat because it appears and spreads so quickly. In this article, we describe the design and implementation of CWSandbox, a malware analysis tool that fulfills our three design criteria of automation, effectiveness, and correctness for the Win32 family of operating systems},
author = {C. Willems and T. Holz and F. Freiling},
journal = {IEEE Security & Privacy},
volume = {5},
pages = {},
doi = {10.1109/MSP.2007.45},
}

@article{952b38a3dc0d3c7e15fbdec8d6ef1fb3a7319ae1,
title = {Obfuscation of executable code to improve resistance to static disassembly},
year = {2003},
url = {https://www.semanticscholar.org/paper/952b38a3dc0d3c7e15fbdec8d6ef1fb3a7319ae1},
abstract = {A great deal of software is distributed in the form of executable code. The ability to reverse engineer such executables can create opportunities for theft of intellectual property via software piracy, as well as security breaches by allowing attackers to discover vulnerabilities in an application. The process of reverse engineering an executable program typically begins with disassembly, which translates machine code to assembly code. This is then followed by various decompilation steps that aim to recover higher-level abstractions from the assembly code. Most of the work to date on code obfuscation has focused on disrupting or confusing the decompilation phase. This paper, by contrast, focuses on the initial disassembly phase. Our goal is to disrupt the static disassembly process so as to make programs harder to disassemble correctly. We describe two widely used static disassembly algorithms, and discuss techniques to thwart each of them. Experimental results indicate that significant portions of executables that have been obfuscated using our techniques are disassembled incorrectly, thereby showing the efficacy of our methods.},
author = {C. Linn and S. Debray},
doi = {10.1145/948109.948149},
}
