@article{2e8d908d141fa33a9abb87a7258da1e1f9fe5230,
title = {Hybrid Analysis and Control of Malware},
year = {2010},
url = {https://www.semanticscholar.org/paper/2e8d908d141fa33a9abb87a7258da1e1f9fe5230},
abstract = {Malware attacks necessitate extensive forensic analysis efforts that are manual-labor intensive because of the analysis-resistance techniques that malware authors employ. The most prevalent of these techniques are code unpacking, code overwriting, and control transfer obfuscations. We simplify the analyst's task by analyzing the code prior to its execution and by providing the ability to selectively monitor its execution. We achieve pre-execution analysis by combining static and dynamic techniques to construct control- and data-flow analyses. These analyses form the interface by which the analyst instruments the code. This interface simplifies the instrumentation task, allowing us to reduce the number of instrumented program locations by a hundred-fold relative to existing instrumentation-based methods of identifying unpacked code. We implement our techniques in SD-Dyninst and apply them to a large corpus of malware, performing analysis tasks such as code coverage tests and call-stack traversals that are greatly simplified by hybrid analysis.},
author = {Kevin A. Roundy and B. Miller},
doi = {10.1007/978-3-642-15512-3_17},
}

@article{57b330fe6a506ab2fb54b6e5efb00e0f2ed4dea9,
title = {RL-BIN++: Overcoming Binary Instrumentation Challenges in the Presence of Obfuscation Techniques and Problematic Features},
year = {2021},
url = {https://www.semanticscholar.org/paper/57b330fe6a506ab2fb54b6e5efb00e0f2ed4dea9},
abstract = {This paper improves upon an earlier binary rewriter we designed called RL-Bin. Unlike static rewrites, which are inherently non-robust, RL-Bin uses a dynamic design and thus is more robust. However, although RL-Bin works for most compiled binaries, real-world features commonly found in obfuscated binaries are still not handled. The features include anti-disassembly, dynamically modified code, anti-rewriting, anti-debugging, and code convention violation. This paper presents RL-Bin++, an improved version of RL-Bin, that handles various problematic real-world features, thus correctly rewriting for nearly all benign binaries. We demonstrate that RL-Bin++ can efficiently instrument heavily obfuscated binaries (overhead averaging 2.76x, compared to 4.11x, and 5.31x overhead for DynamoRIO and Pin, which are comparable or lower overheads. However, the main achievement is that we achieved this while maintaining the low overhead of RL-Bin for unobfuscated binaries (only 1.05x). This makes RL-Bin++ the only robust binary instrumentation solution capable of being deployed in live systems since the overhead of DynamoRIO (1.16x), and Pin (1.29x) for unobfuscated binaries is too high for use in live systems.},
author = {Amir Majlesi-Kupaei and Danny Kim and R. Barua},
journal = {2021 10th International Conference on Software and Computer Applications},
volume = {},
pages = {},
doi = {10.1145/3457784.3457825},
}

@article{974f362d3fcabfba7befbb7cba9d8027d5942f35,
title = {Binary-code obfuscations in prevalent packer tools},
year = {2013},
url = {https://www.semanticscholar.org/paper/974f362d3fcabfba7befbb7cba9d8027d5942f35},
abstract = {The first steps in analyzing defensive malware are understanding what obfuscations are present in real-world malware binaries, how these obfuscations hinder analysis, and how they can be overcome. While some obfuscations have been reported independently, this survey consolidates the discussion while adding substantial depth and breadth to it. This survey also quantifies the relative prevalence of these obfuscations by using the Dyninst binary analysis and instrumentation tool that was recently extended for defensive malware analysis. The goal of this survey is to encourage analysts to focus on resolving the obfuscations that are most prevalent in real-world malware.},
author = {Kevin A. Roundy and B. Miller},
journal = {ACM Comput. Surv.},
volume = {46},
pages = {4:1-4:32},
doi = {10.1145/2522968.2522972},
}

@article{56cce99fe942634c4419c797dd26331d87d66acb,
title = {DynODet: Detecting Dynamic Obfuscation in Malware},
year = {2017},
url = {https://www.semanticscholar.org/paper/56cce99fe942634c4419c797dd26331d87d66acb},
abstract = {Malicious software, better known as malware, is a major threat to society. Malware today typically employ a technique called obfuscation. Obfuscation detection in malware is a well-documented problem and has been analyzed using dynamic analysis. However, many tools that detect obfuscation in malware make no attempts to use the presence of obfuscation as a method of detecting malware because their schemes would also detect benign applications. We present three main contributions. First, we conduct a unique study into the prevalence of obfuscation in benign applications. Second, we create discriminating features that can distinguish obfuscation in benign applications versus malware. Third, we prove that using the presence of obfuscation can detect previously hard-to-detect malware. Our results show that for our set of programs, we are able to reduce the number of malware missed by five market-leading AV tools by 25% while only falsely detecting 2.45% of tested benign applications.},
author = {Danny Kim and Amir Majlesi-Kupaei and Julien Roy and K. Anand and Khaled Elwazeer and Daniel Buettner and R. Barua},
doi = {10.1007/978-3-319-60876-1_5},
}

@article{a466428f79113489dbc68111c2881acfb77325de,
title = {Towards Paving the Way for Large-Scale Windows Malware Analysis: Generic Binary Unpacking with Orders-of-Magnitude Performance Boost},
year = {2018},
url = {https://www.semanticscholar.org/paper/a466428f79113489dbc68111c2881acfb77325de},
abstract = {Binary packing, encoding binary code prior to execution and decoding them at run time, is the most common obfuscation adopted by malware authors to camouflage malicious code. Especially, most packers recover the original code by going through a set of "written-then-executed" layers, which renders determining the end of the unpacking increasingly difficult. Many generic binary unpacking approaches have been proposed to extract packed binaries without the prior knowledge of packers. However, the high runtime overhead and lack of anti-analysis resistance have severely limited their adoptions. Over the past two decades, packed malware is always a veritable challenge to anti-malware landscape. This paper revisits the long-standing binary unpacking problem from a new angle: packers consistently obfuscate the standard use of API calls. Our in-depth study on an enormous variety of Windows malware packers at present leads to a common property: malware's Import Address Table (IAT), which acts as a lookup table for dynamically linked API calls, is typically erased by packers for further obfuscation; and then unpacking routine, like a custom dynamic loader, will reconstruct IAT before original code resumes execution. During a packed malware execution, if an API is invoked through looking up a rebuilt IAT, it indicates that the original payload has been restored. This insight motivates us to design an efficient unpacking approach, called BinUnpack. Compared to the previous methods that suffer from multiple "written-then-executed" unpacking layers, BinUnpack is free from tedious memory access monitoring, and therefore it introduces very small runtime overhead. To defeat a variety of ever-evolving evasion tricks, we design BinUnpack's API monitor module via a novel kernel-level DLL hijacking technique. We have evaluated BinUnpack's efficacy extensively with more than 238K packed malware and multiple Windows utilities. BinUnpack's success rate is significantly better than that of existing tools with several orders of magnitude performance boost. Our study demonstrates that BinUnpack can be applied to speeding up large-scale malware analysis.},
author = {Binlin Cheng and Jiang Ming and Jianming Fu and Guojun Peng and Ting Chen and Xiaosong Zhang and J. Marion},
journal = {Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security},
volume = {},
pages = {},
doi = {10.1145/3243734.3243771},
}

@article{1e4e04a06d1a340d8ffb3227feb4b466a15439f8,
title = {Automatic Reverse Engineering of Malware Emulators},
year = {2009},
url = {https://www.semanticscholar.org/paper/1e4e04a06d1a340d8ffb3227feb4b466a15439f8},
abstract = {Malware authors have recently begun using emulation technology to obfuscate their code. They convert native malware binaries into bytecode programs written in a randomly generated instruction set and paired with a native binary emulator that interprets the bytecode. No existing malware analysis can reliably reverse this obfuscation technique. In this paper, we present the first work in automatic reverse engineering of malware emulators. Our algorithms are based on dynamic analysis. We execute the emulated malware in a protected environment and record the entire x86 instruction trace generated by the emulator. We then use dynamic data-flow and taint analysis over the trace to identify data buffers containing the bytecode program and extract the syntactic and semantic information about the bytecode instruction set. With these analysis outputs, we are able to generate data structures, such as control-flow graphs, that provide the foundation for subsequent malware analysis. We implemented a proof-of-concept system called Rotalume and evaluated it using both legitimate programs and malware emulated by VMProtect and Code Virtualizer. The results show that Rotalume accurately reveals the syntax and semantics of emulated instruction sets and reconstructs execution paths of original programs from their bytecode representations.},
author = {Monirul I. Sharif and A. Lanzi and Jonathon T. Giffin and Wenke Lee},
journal = {2009 30th IEEE Symposium on Security and Privacy},
volume = {},
pages = {94-109},
doi = {10.1109/SP.2009.27},
}

@article{e48e14e05f3b8f80c9c9f8b1d154682a03bde81f,
title = {Memory behavior-based automatic malware unpacking in stealth debugging environment},
year = {2010},
url = {https://www.semanticscholar.org/paper/e48e14e05f3b8f80c9c9f8b1d154682a03bde81f},
abstract = {Malware analysts have to first extract hidden original code from a packed executable to analyze malware because most recent malware is obfuscated by a packer in order to disrupt analysis by debuggers and dis-assemblers. There are several studies on automatic extraction of hidden original code, which executes malware in an isolated environment, monitors write memory accesses and instruction fetches at runtime, determines if the code under execution is newly generated, then dumps specific memory areas into a file as candidates for the original code. However, the conventional techniques output many dump files as candidates for the original code when experiments are conducted on malware in the wild. Thus, manual identification of the true original code is needed. In this paper, we present “memory behavior-based unpacking,” an algorithm that automatically identifies the true original code from among many candidates depending on the change in the trend of accessed memory addresses before and after the dumping points. To achieve this algorithm, we have implemented Stealth Debugger, a virtual machine monitor for debugging and monitoring all memory accesses of a process without interruption by any anti-debug functions of the malware. We have evaluated our proposed system by using malware obfuscated by various common packers. The results show that our proposed system successfully finds the original entry points and obtains the original code of the malware.},
author = {Yuhei Kawakoya and Makoto Iwamura and M. Itoh},
journal = {2010 5th International Conference on Malicious and Unwanted Software},
volume = {},
pages = {39-46},
doi = {10.1109/MALWARE.2010.5665794},
}

@article{755d7f51eaa9c77a8b1b2fc3fba8994681aa8f21,
title = {Robust and efficient malware analysis and host-based monitoring},
year = {2010},
url = {https://www.semanticscholar.org/paper/755d7f51eaa9c77a8b1b2fc3fba8994681aa8f21},
abstract = {Over the last few years, a tremendous increase has occurred in the rate in which new malware is appearing in the Internet. Today, organized cybercriminals are using malware as their primary vehicle for carrying out various cyberattacks on computers for huge financial gains. On the defense side, host-based malware detection approaches such as antivirus programs are severely lagging. Industrial average detection rates range from 18% for zero day to 60% for one month old malware samples. The two important aspects that the overall effectiveness of malware detection depend on are the success of extracting information from malware using malware analysis to generate signatures, and then the success of utilizing these signatures on target hosts with appropriate system monitoring techniques. Today's malware employ a vast array of anti-analysis and anti-monitoring techniques to deter analysis and to neutralize antivirus programs, reducing the overall success of malware detection. 
In this dissertation, we present a set of practical approaches of robust and efficient malware analysis and system monitoring that can help make malware detection on hosts become more effective. The contributions are summarized below: 
(1) Efficient Methods for Enabling Static Malware Analysis: Static malware analysis suffers greatly for its susceptibility to obfuscations employed by malware. However, it can provide complementary insight to dynamic analysis in those cases where obfuscations can be sufficiently overcome. We present Eureka, a framework that efficiently deobfuscates single-pass and multi-pass packed binaries and restores obfuscated API calls, providing a basis for extracting comprehensive information from the malware using further static analysis. 
(2) Making Dynamic Analysis Approaches more Robust: While dynamic analysis techniques provide better resilience to malware obfuscations than static analysis, it is susceptible to evasion attacks that detect the presence of a run-time analysis environment. We present the formal framework of transparent malware analysis and Ether, a dynamic malware analysis environment based on this framework that provides transparent fine-(single instruction) and coarse-(system call) granularity tracing. 
(3) Anticipating Obfuscations that Hide Trigger-based Behavior: Multipath exploring dynamic analysis overcomes the limitation of straightforward dynamic analysis, which may miss trigger-based behavior for its limited view of execution paths. We introduce an input-based obfuscation technique that hides trigger-based behavior from any input-oblivious analyzer. We present the analysis of strengths and weaknesses of this obfuscation and explain how such a technique can impact the efficiency and effectiveness of malware analysis. 
(4) Reversing Emulator based Obfuscation: Recently, malware authors have adopted emulation as a forms of fine-grained obfuscation that can affect the robustness of both white-box and gray-box analysis techniques. We present an approach that automatically reverse-engineers the emulator and extracts the syntax and semantics of the bytecode language, which helps constructing control-flow graphs of the bytecode program and enables further analysis on the malicious code. 
(5) Robust and Efficient System Monitoring Techniques: Antivirus programs require monitoring of the target host for code and events that are matched with the signatures or behavior models that they employ, overcoming disabling attacks used by malware. We present Secure In-VM Monitoring, an approach of efficiently monitoring a target host while being robust against unknown malware that may attempt to neutralize security tools.},
author = {Monirul I. Sharif},
}

@article{c11f55a1f5b1049664ff99e869baae5aab010c8b,
title = {Structured Binary Editing with a CFG Transformation Algebra},
year = {2012},
url = {https://www.semanticscholar.org/paper/c11f55a1f5b1049664ff99e869baae5aab010c8b},
abstract = {Binary modification allows users to alter existing code or inject new code into programs without requiring source code, symbols, or debugging information. It is critically important that such modification not accidentally create a structurally invalid binary that has illegal control flow or executes invalid instructions. Unfortunately, current modification tools do not make this guarantee, instead relying on the user to manually ensure the modified binary is valid. In addition, they fail to provide high-level abstractions of the binary (e.g., functions), instead requiring the user to have a deep understanding of the idiosyncrasies of the instruction set and the behavior of the program. We present structured binary editing, which allows users to modify a program binary by modifying its control flow graph (CFG). We define an algebra of CFG transformations that is closed under a CFG validity constraint, thus ensuring that users can arbitrarily compose these transformations while preserving structural validity. We have implemented structured binary editing in the Dyninst binary analysis and instrumentation framework, creating a high-level binary modification toolkit. We demonstrate the usefulness of our approach by creating a hot patching tool that closes three vulnerabilities in a running, unmodified Apache HTTPD server without interrupting the server's execution.},
author = {Andrew R. Bernat and B. Miller},
journal = {2012 19th Working Conference on Reverse Engineering},
volume = {},
pages = {9-18},
doi = {10.1109/WCRE.2012.11},
}

@article{4073cbf1ab4fd323787af8a624bc360ae1717546,
title = {Behavioral analysis of malicious code through network traffic and system call monitoring},
year = {2011},
url = {https://www.semanticscholar.org/paper/4073cbf1ab4fd323787af8a624bc360ae1717546},
abstract = {Malicious code (malware) that spreads through the Internet-such as viruses, worms and trojans-is a major threat to information security nowadays and a profitable business for criminals. There are several approaches to analyze malware by monitoring its actions while it is running in a controlled environment, which helps to identify malicious behaviors. In this article we propose a tool to analyze malware behavior in a non-intrusive and effective way, extending the analysis possibilities to cover malware samples that bypass current approaches and also fixes some issues with these approaches.},
author = {A. Grégio and Dario S. Fernandes Filho and V. M. Afonso and Rafael D. C. Santos and Mario Jino and P. D. de Geus},
doi = {10.1117/12.883457},
}

@article{478ad0c00e6c8f2cdb9006785d1972cf652758a0,
title = {Deobfuscation of Packed and Virtualization-Obfuscation Protected Binaries},
year = {2011},
url = {https://www.semanticscholar.org/paper/478ad0c00e6c8f2cdb9006785d1972cf652758a0},
abstract = {Code obfuscation techniques are increasingly being used in software for such reasons as protecting trade secret algorithms from competitors and deterring license tampering by those wishing to use the software for free. However, these techniques have also grown in popularity in less legitimate areas, such as protecting malware from detection and reverse engineering. This work examines two such techniques – packing and virtualization-obfuscation – and presents new behavioral approaches to analysis that may be relevant to security analysts whose job it is to defend against malicious code. These approaches are robust against variations in obfuscation algorithms, such as changing encryption keys or virtual instruction byte code. 
Packing refers to the process of encrypting or compressing an executable file. This process “scrambles” the bytes of the executable so that byte-signature matching algorithms commonly used by anti-virus programs are ineffective. Standard static analysis techniques are similarly ineffective since the actual byte code of the program is hidden until after the program is executed. Dynamic analysis approaches exist, but are vulnerable to dynamic defenses. We detail a static analysis technique that starts by identifying the code used to “unpack” the executable, then uses this unpacker to generate the unpacked code in a form suitable for static analysis. Results show we are able to correctly unpack several encrypted and compressed malware, while still handling several dynamic defenses. 
Virtualization-obfuscation is a technique that translates the original program into virtual instructions, then builds a customized virtual machine for these instructions. As with packing, the byte-signature of the original program is destroyed. Furthermore, static analysis of the obfuscated program reveals only the structure of the virtual machine, and dynamic analysis produces a dynamic trace where original program instructions are intermixed, and often indistinguishable from, virtual machine instructions. We present a dynamic analysis approach whereby all instructions that affect the external behavior of the program are identified, thus building an approximation of the original program that is observationally equivalent. We achieve good results at both identifying instructions from the original program, as well as eliminating instructions known to be part of the virtual machine.},
author = {Kevin Coogan},
}

@article{b35121069bbd6fded1d05cd0933bead4dd825ac0,
title = {Anywhere, any-time binary instrumentation},
year = {2011},
url = {https://www.semanticscholar.org/paper/b35121069bbd6fded1d05cd0933bead4dd825ac0},
abstract = {The Dyninst binary instrumentation and analysis framework distinguishes itself from other binary instrumentation tools through its abstract, machine independent interface; its emphasis on anywhere, any-time binary instrumentation; and its low overhead that is proportional to the number of instrumented locations. Dyninst represents the program in terms of familiar control flow structures such as functions, loops, and basic blocks, and users manipulate these representations to insert instrumentation anywhere in the binary. We use graph transformation techniques to insure that this instrumentation executes when desired even when instrumenting highly optimized (or malicious) code that other instrumenters cannot correctly instrument. Unlike other binary instrumenters, Dyninst can instrument at any time in the execution continuum, from static instrumentation (binary rewriting) to instrumenting actively executing code (dynamic instrumentation). Furthermore, we allow users to modify or remove instrumentation at any time, with such modifications taking immediate effect. Our analysis techniques allow us to insert new code without modifying uninstrumented code; as a result, all uninstrumented code executes at native speed. We demonstrate that our techniques provide this collection of capabilities while imposing similar or lower overhead than other widely used instrumenters.},
author = {Andrew R. Bernat and B. Miller},
doi = {10.1145/2024569.2024572},
}

@article{685606c8e2c170a8d5f3cba1f014012ecc86457e,
title = {Impeding Malware Analysis Using Conditional Code Obfuscation},
year = {2008},
url = {https://www.semanticscholar.org/paper/685606c8e2c170a8d5f3cba1f014012ecc86457e},
abstract = {Malware programs that incorporate trigger-based behavior initiate malicious activities based on conditions satisfied only by specific inputs. State-of-the-art malware analyzers discover code guarded by triggers via multiple path exploration, symbolic execution, or forced conditional execution, all without knowing the trigger inputs. We present a malware obfuscation technique that automatically conceals specific trigger-based behavior from these malware analyzers. Our technique automatically transforms a program by encrypting code that is conditionally dependent on an input value with a key derived from the input and then removing the key from the program. We have implemented a compiler-level tool that takes a malware source program and automatically generates an obfuscated binary. Experiments on various existing malware samples show that our tool can hide a significant portion of trigger based code. We provide insight into the strengths, weaknesses, and possible ways to strengthen current analysis approaches in order to defeat this malware obfuscation technique.},
author = {Monirul I. Sharif and A. Lanzi and Jonathon T. Giffin and Wenke Lee},
}

@article{8500d6acfca1888faea71dd85c26b0ca1f05fb35,
title = {Reverse Code Engineering — State of the Art and Countermeasures},
year = {2012},
url = {https://www.semanticscholar.org/paper/8500d6acfca1888faea71dd85c26b0ca1f05fb35},
abstract = {Abstract Reverse Code Engineering (RCE) is, loosely speaking, the process of analyzing a piece of code in order to understand it. RCE is often used to analyze proprietary, binary programs, and in the last few years this research area has evolved a lot. In this article, we survey and structure the area of reverse code engineering. We focus on different techniques to recover both the control and data flow of a given binary program, for which no source code is available. Furthermore, we also discuss analysis techniques for malicious software (short: malware), which is commonly protected to resist analysis. We present the current state of the art of such protection techniques, while dividing them into active and passive measures. Our survey focusses on reverse engineering of binary native code for the Intel/AMD x86 architecture, and we thus disregard analysis of byte-code like Java or .NET. Nevertheless, most of the techniques presented in this article can be transferred to other architectures and operating system as well. Zusammenfassung Reverse Code Engineering (RCE) ist die Analyse von Binärprogrammen mit dem Ziel, deren Semantik zu verstehen. Traditionell wird dabei vor allem proprietäre Software untersucht, für die kein Sourcecode verfügbar ist. In letzter Zeit hat es jedoch eine enorme Ausweitung auch auf andere Einsatzgebiete gegeben. In diesem Bericht werden die verschiedenen Bereiche und Einsatzgebiete vorgestellt und eine Strukturierung vorgenommen. Dabei wird im ersten Teil auf die verschiedenen Methoden zur Rückgewinnung von Kontroll- und Datenfluss unbekannter Software eingegangen. Im zweiten Teil werden ausführlich die verschiedenen Schutzmaßnahmen behandelt, die von Programmen eingesetzt werden, um sich einer solchen Analyse zu entziehen. Der Fokus liegt dabei in der Analyse von Binärcode für die Intel/AMD x86 Architektur. Daher wird das Gebiet der heutigen Bytecode-Sprachen wie Java or .NET vernachlässigt. Die vorgestellten Methoden und Verfahren lassen sich jedoch problemlos auch auf andere Hardware- und Software-Architekturen übertragen.},
author = {C. Willems and F. Freiling},
doi = {10.1524/itit.2012.0664},
}

@article{4a250eef9f4897c47d28547b9e88327fb23dc7e9,
title = {CoDisasm: Medium Scale Concatic Disassembly of Self-Modifying Binaries with Overlapping Instructions},
year = {2015},
url = {https://www.semanticscholar.org/paper/4a250eef9f4897c47d28547b9e88327fb23dc7e9},
abstract = {Fighting malware involves analyzing large numbers of suspicious binary files. In this context, disassembly is a crucial task in malware analysis and reverse engineering. It involves the recovery of assembly instructions from binary machine code. Correct disassembly of binaries is necessary to produce a higher level representation of the code and thus allow the analysis to develop high-level understanding of its behavior and purpose. Nonetheless, it can be problematic in the case of malicious code, as malware writers often employ techniques to thwart correct disassembly by standard tools. In this paper, we focus on the disassembly of x86 self-modifying binaries with overlapping instructions. Current state-of-the-art disassemblers fail to interpret these two common forms of obfuscation, causing an incorrect disassembly of large parts of the input. We introduce a novel disassembly method, called concatic disassembly, that combines CONCrete path execution with stATIC disassembly. We have developed a standalone disassembler called CoDisasm that implements this approach. Our approach substantially improves the success of disassembly when confronted with both self-modification and code overlap in analyzed binaries. To our knowledge, no other disassembler thwarts both of these obfuscations methods together.},
author = {Guillaume Bonfante and José M. Fernandez and J. Marion and Benjamin Rouxel and Fabrice Sabatier and Aurélien Thierry},
journal = {Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security},
volume = {},
pages = {},
doi = {10.1145/2810103.2813627},
}

@article{6bbd585a24d95171222965b20fc1a78ce8faa271,
title = {RAMBO: Run-Time Packer Analysis with Multiple Branch Observation},
year = {2016},
url = {https://www.semanticscholar.org/paper/6bbd585a24d95171222965b20fc1a78ce8faa271},
abstract = {Run-time packing is a technique employed by malware authors in order to conceal e.g., encrypt malicious code and recover it at run-time. In particular, some run-time packers only decrypt individual regions of code on demand, re-encrypting them again when they are not running. This technique is known as shifting decode frames and it can greatly complicate malware analysis. The first solution that comes to mind to analyze these samples is to apply multi-path exploration to trigger the unpacking of all the code regions. Unfortunately, multi-path exploration is known to have several limitations, such as its limited scalability for the analysis of real-world binaries. In this paper, we propose a set of domain-specific optimizations and heuristics to guide multi-path exploration and improve its efficiency and reliability for unpacking binaries protected with shifting decode frames.},
author = {Xabier Ugarte-Pedrero and D. Balzarotti and I. Santos and P. G. Bringas},
doi = {10.1007/978-3-319-40667-1_10},
}

@article{d2ad315eb328dbe97f2a33ae297a30c8570136f4,
title = {A survey on automated dynamic malware-analysis techniques and tools},
year = {2012},
url = {https://www.semanticscholar.org/paper/d2ad315eb328dbe97f2a33ae297a30c8570136f4},
abstract = {Anti-virus vendors are confronted with a multitude of potentially malicious samples today. Receiving thousands of new samples every day is not uncommon. The signatures that detect confirmed malicious threats are mainly still created manually, so it is important to discriminate between samples that pose a new unknown threat and those that are mere variants of known malware.
 This survey article provides an overview of techniques based on dynamic analysis that are used to analyze potentially malicious samples. It also covers analysis programs that leverage these It also covers analysis programs that employ these techniques to assist human analysts in assessing, in a timely and appropriate manner, whether a given sample deserves closer manual inspection due to its unknown malicious behavior.},
author = {Manuel Egele and T. Scholte and E. Kirda and Christopher Krügel},
journal = {ACM Comput. Surv.},
volume = {44},
pages = {6:1-6:42},
doi = {10.1145/2089125.2089126},
}

@article{28d1465ed7e378d4cf778f58fe4c4eaf33652251,
title = {RePEconstruct: reconstructing binaries with self-modifying code and import address table destruction},
year = {2016},
url = {https://www.semanticscholar.org/paper/28d1465ed7e378d4cf778f58fe4c4eaf33652251},
abstract = {Reverse engineering packed binaries remain a tedious challenge as code packing is continuously being used by malware to hinder detection and analysis. The problem of automatically unpacking binaries has previously been investigated. However, current generic unpackers either do not offer any dump of the unpacked binary at all or produces a set of memory dumps that each lack several structures that make them well-suited for further analysis. In this paper, we present RePEconstruct, a tool that unpacks packed binaries and reconstructs them in a manner well suited for further analysis. RePEconstruct deploys a model of self-modifying code similar to previous work but goes the step further by also utilizing a novel, aggressive, approach to rebuilding the import address table. Our approach relies on both static and dynamic analysis. We build RePEconstruct as a DynamoRIO client and successfully evaluate it against a set of packed applications.},
author = {D. Korczynski},
journal = {2016 11th International Conference on Malicious and Unwanted Software (MALWARE)},
volume = {},
pages = {1-8},
doi = {10.1109/MALWARE.2016.7888727},
}

@article{b6e1f279411da924582d15582c9d9ee5fba8dd60,
title = {Down to the bare metal: using processor features for binary analysis},
year = {2012},
url = {https://www.semanticscholar.org/paper/b6e1f279411da924582d15582c9d9ee5fba8dd60},
abstract = {A detailed understanding of the behavior of exploits and malicious software is necessary to obtain a comprehensive overview of vulnerabilities in operating systems or client applications, and to develop protection techniques and tools. To this end, a lot of research has been done in the last few years on binary analysis techniques to efficiently and precisely analyze code. Most of the common analysis frameworks are based on software emulators since such tools offer a fine-grained control over the execution of a given program. Naturally, this leads to an arms race where the attackers are constantly searching for new methods to detect such analysis frameworks in order to successfully evade analysis.
 In this paper, we focus on two aspects. As a first contribution, we introduce several novel mechanisms by which an attacker can delude an emulator. In contrast to existing detection approaches that perform a dedicated test on the environment and combine the test with an explicit conditional branch, our detection mechanisms introduce code sequences that have an implicitly different behavior on a native machine when compared to an emulator. Such differences in behavior are caused by the side-effects of the particular operations and imperfections in the emulation process that cannot be mitigated easily. Motivated by these findings, we introduce a novel approach to generate execution traces. We propose to utilize the processor itself to generate such traces. Mores precisely, we propose to use a hardware feature called branch tracing available on commodity x86 processors in which the log of all branches taken during code execution is generated directly by the processor. Effectively, the logging is thus performed at the lowest level possible. We evaluate the practical viability of this approach.},
author = {C. Willems and R. Hund and Andreas Fobian and Dennis Felsch and T. Holz and A. Vasudevan},
doi = {10.1145/2420950.2420980},
}

@article{c90beb65c353fd6a09d504dbbd00d58c559e49e5,
title = {Internals of Windows Memory Management (not only) for Malware Analysis},
year = {2011},
url = {https://www.semanticscholar.org/paper/c90beb65c353fd6a09d504dbbd00d58c559e49e5},
abstract = {This document presents insights from extensive reverse engineering efforts of the memory management mechanisms of Windows XP. The focus lies on (1) the mechanisms which are used to map executable modules into the address space and (2) the role of the page fault handler in this context.},
author = {C. Willems},
}

@article{be0f5d8efcf6e5102d3db719a9e10ebab22b3bf9,
title = {Hybrid analysis and control of malicious code},
year = {2012},
url = {https://www.semanticscholar.org/paper/be0f5d8efcf6e5102d3db719a9e10ebab22b3bf9},
abstract = {State of the art analysis techniques for malicious executables lag significantly behind their counterparts for compiler-generated executables. This difference exists because 90% of malicious software (also known as malware) actively resists analysis. In particular, most malware resists static attempts to recover structural information from its binary code, and resists dynamic attempts to observe and modify its code. 
In this dissertation, we develop static and dynamic techniques and combine them in a hybrid algorithm that preserves the respective strengths of these techniques while mitigating their weaknesses. In particular, we build structural analyses with static parsing techniques that can disassemble arbitrarily obfuscated binary code with high accuracy, and recover the structure of that code in terms of functions, loops, and basic blocks. We develop dynamic techniques to identify transitions into statically unreachable code and respond to malware that overwrites its code. These dynamic techniques remove overwritten and unreachable code from our analysis and trigger additional parsing at entry points into un-analyzed code, before this code executes. Our stealthy instrumentation techniques leverage our structural analysis to stealthily and efficiently instrument binary code that resists modification. These instrumentation techniques hide the modifications they make to the binary code, and the additional space that they allocate in the program's address space to hold instrumentation. 
We demonstrate the utility of our techniques by adapting the Dyninst 7.0 binary analysis and instrumentation tool so that its users can analyze defensive malware code in exactly the same way that they analyze non-defensive binaries. We also build customizable malware analysis factories that perform batch-processing of malware binaries in an isolated environment, to help security companies efficiently process the tens of thousands of new malware samples that they receive each day. Finally, we use our analysis factory to study the most prevalent defensive techniques used by malware binaries. We thereby provide a snapshot of the obfuscation techniques that we have seen to date, and demonstrate that our techniques allow us to analyze and instrument highly defensive binary code.},
author = {B. Miller and Kevin A. Roundy},
}

@article{5007318bb6b3d3f6a5d6392aa23d95d54ec2af64,
title = {Unpacking virtualization obfuscators},
year = {2009},
url = {https://www.semanticscholar.org/paper/5007318bb6b3d3f6a5d6392aa23d95d54ec2af64},
abstract = {Nearly every malware sample is sheathed in an executable protection which must be removed before static analyses can proceed. Existing research has studied automatically unpacking certain protections, but has not yet caught up with many modern techniques. Contrary to prior assumptions, protected programs do not always have the property that they are reverted to a fully unprotected state at some point during the course of their execution. This work provides a novel technique for circumventing one of the most problematic features of modern software protections, so-called virtualization obfuscation. The technique enables analysis of heretofore impenetrable malware.},
author = {R. Rolles},
}

@article{27d019782a49d97ea32b07da60ee908042e9b6f8,
title = {Maitland: Lighter-Weight VM Introspection to Support Cyber-security in the Cloud},
year = {2012},
url = {https://www.semanticscholar.org/paper/27d019782a49d97ea32b07da60ee908042e9b6f8},
abstract = {Despite defensive advances, malicious software (malware) remains an ever present cyber-security threat. Cloud environments are far from malware immune, in that: i) they innately support the execution of remotely supplied code, and ii) escaping their virtual machine (VM) confines has proven relatively easy to achieve in practice. The growing interest in clouds by industries and governments is also creating a core need to be able to formally address cloud security and privacy issues. VM introspection provides one of the core cyber-security tools for analyzing the run-time behaviors of code. Traditionally, introspection approaches have required close integration with the underlying hypervisors and substantial re-engineering when OS updates and patches are applied. Such heavy-weight introspection techniques, therefore, are too invasive to fit well within modern commercial clouds. Instead, lighter-weight introspection techniques are required that provide the same levels of within-VM observability but without the tight hypervisor and OS patch-level integration. This work introduces Maitland as a prototype proof-of-concept implementation a lighter-weight introspection tool, which exploits paravirtualization to meet these end-goals. The work assesses Maitland's performance, highlights its use to perform packer-independent malware detection, and assesses whether, with further optimizations, Maitland could provide a viable approach for introspection in commercial clouds.},
author = {Chris Benninger and S. Neville and Y. Yazir and Chris Matthews and Y. Coady},
journal = {2012 IEEE Fifth International Conference on Cloud Computing},
volume = {},
pages = {471-478},
doi = {10.1109/CLOUD.2012.145},
}

@article{e396249ffcdef50c61222b1118b8a7138262eb32,
title = {SoK: Deep Packer Inspection: A Longitudinal Study of the Complexity of Run-Time Packers},
year = {2015},
url = {https://www.semanticscholar.org/paper/e396249ffcdef50c61222b1118b8a7138262eb32},
abstract = {Run-time packers are often used by malware-writers to obfuscate their code and hinder static analysis. The packer problem has been widely studied, and several solutions have been proposed in order to generically unpack protected binaries. Nevertheless, these solutions commonly rely on a number of assumptions that may not necessarily reflect the reality of the packers used in the wild. Moreover, previous solutions fail to provide useful information about the structure of the packer or its complexity. In this paper, we describe a framework for packer analysis and we propose a taxonomy to measure the runtime complexity of packers. We evaluated our dynamic analysis system on two datasets, composed of both off-the-shelf packers and custom packed binaries. Based on the results of our experiments, we present several statistics about the packers complexity and their evolution over time.},
author = {Xabier Ugarte-Pedrero and D. Balzarotti and I. Santos and P. G. Bringas},
journal = {2015 IEEE Symposium on Security and Privacy},
volume = {},
pages = {659-673},
doi = {10.1109/SP.2015.46},
}

@article{0a21dc4152e5d55c60bfd7e99b0c335c3ad23492,
title = {Maitland: analysis of packed and encrypted malware via paravirtualization extensions},
year = {2012},
url = {https://www.semanticscholar.org/paper/0a21dc4152e5d55c60bfd7e99b0c335c3ad23492},
abstract = {},
author = {Chris Benninger},
}

@article{80d4d1dee6f80ce3166c99c97d9da6ed222a04e5,
title = {Fast Automated Unpacking and Classification of Malware},
year = {2010},
url = {https://www.semanticscholar.org/paper/80d4d1dee6f80ce3166c99c97d9da6ed222a04e5},
abstract = {},
author = {Silvio Cesare},
}

@article{dc02957a16ca05f6d7eeb9752d1ccb64fa498306,
title = {A Framework for Analysis and Comparison of Dynamic Malware Analysis Tools},
year = {2014},
url = {https://www.semanticscholar.org/paper/dc02957a16ca05f6d7eeb9752d1ccb64fa498306},
abstract = {Malware writers have employed various obfuscation and polymorphism techniques to thwart static analysis approaches and bypassing antivirus tools. Dynamic analysis techniques, however, have essentially overcome these deceits by observing the actual behaviour of the code execution. In this regard, various methods, techniques and tools have been proposed. However, because of the diverse concepts and strategies used in the implementation of these methods and tools, security researchers and malware analysts find it difficult to select the required optimum tool to investigate the behaviour of a malware and to contain the associated risk for their study. Focusing on two dynamic analysis techniques: Function Call monitoring and Information Flow Tracking, this paper presents a comparison framework for dynamic malware analysis tools. The framework will assist the researchers and analysts to recognize the tools implementation strategy, analysis approach, system wide analysis support and its overall handling of binaries, helping them to select a suitable and effective one for their study and analysis.},
author = {Waqas Aman},
journal = {ArXiv},
volume = {abs/1410.2131},
pages = {},
doi = {10.5121/ijnsa.2014.6505},
arxivid = {1410.2131},
}

@article{36f538b479322c04595d5bdc5477e92c41ad3871,
title = {Eureka: A Framework for Enabling Static Malware Analysis},
year = {2008},
url = {https://www.semanticscholar.org/paper/36f538b479322c04595d5bdc5477e92c41ad3871},
abstract = {We introduce Eureka, a framework for enabling static analysis on Internet malware binaries. Eureka incorporates a novel binary unpacking strategy based on statistical bigram analysis and coarse-grained execution tracing. The Eureka framework uniquely distinguishes itself from prior work by providing effective evaluation metrics and techniques to assess the quality of the produced unpacked code. Eureka provides several Windows API resolution techniques that identify system calls in the unpacked code by overcoming various existing control flow obfuscations. Eureka's unpacking and API resolution capabilities facilitate the structural analysis of the underlying malware logic by means of micro-ontology generation that labels groupings of identified API calls based on their functionality. They enable a visual means for understanding malware code through the automated construction of annotated control flow and call graphs.Our evaluation on multiple datasets reveals that Eureka can simplify analysis on a large fraction of contemporary Internet malware by successfully unpacking and deobfuscating API references.},
author = {Monirul I. Sharif and V. Yegneswaran and Hassen Saïdi and Phillip A. Porras and Wenke Lee},
doi = {10.1007/978-3-540-88313-5_31},
}

@article{01e90e360114da419a98591c2b58ec54154d6a0b,
title = {Reverse Engineering Self-Modifying Code: Unpacker Extraction},
year = {2010},
url = {https://www.semanticscholar.org/paper/01e90e360114da419a98591c2b58ec54154d6a0b},
abstract = {An important application of binary-level reverse engineering is in reconstructing the internal logic of computer malware. Most malware code is distributed in encrypted (or "packed") form, at runtime, an unpacker routine transforms this to the original executable form of the code, which is then executed. Most of the existing work on analysis of such programs focuses on detecting unpacking and extracting the unpacked code. However, this does not shed any light on the functionality of different portions of the code so obtained, and in particular does not distinguish between code that performs unpacking and code that does not, identifying such functionality can be helpful for reverse engineering the code. This paper describes a technique for identifying and extracting the unpacker code in a self-modifying program. Our algorithm uses offline analysis of a dynamic instruction trace both to identify the point(s) where unpacking occurs and to identify and extract the corresponding unpacker code.},
author = {S. Debray and Jay Patel},
journal = {2010 17th Working Conference on Reverse Engineering},
volume = {},
pages = {131-140},
doi = {10.1109/WCRE.2010.22},
}

@article{478484f66832b4ba799682f153f329520b7d2084,
title = {An Empirical Evaluation of an Unpacking Method Implemented with Dynamic Binary Instrumentation},
year = {2011},
url = {https://www.semanticscholar.org/paper/478484f66832b4ba799682f153f329520b7d2084},
abstract = {Many malicious programs we encounter these days are armed with their own custom encoding methods (i.e., they are packed) to deter static binary analysis. Thus, the initial step to deal with unknown (possibly malicious) binary samples obtained from malware collecting systems ordinarily involves the unpacking step. In this paper, we focus on empirical experimental evaluations on a generic unpacking method built on a dynamic binary instrumentation (DBI)framework to figure out the applicability of the DBI-based approach. First, we present yet another method of generic binary unpacking extending a conventional unpacking heuristic. Our architecture includes managing shadow states to measure code exposure according to a simple byte state model. Among available platforms, we built an unpacking implementation on PIN DBI framework. Second, we describe evaluation experiments, conducted on wild malware collections, to discuss workability as well as limitations of our tool. Without the prior knowledge of 6029 samples in the collections, we have identified at around 64% of those were analyzable with our DBI-based generic unpacking tool which is configured to operate in fully automatic batch processing. Purging corrupted and unworkable samples in native systems, it was 72%.},
author = {Hyung Chan Kim and Tatsunori Orii and K. Yoshioka and D. Inoue and Jungsuk Song and Masashi Eto and Junji Shikata and Tsutomu Matsumoto and K. Nakao},
journal = {IEICE Trans. Inf. Syst.},
volume = {94-D},
pages = {1778-1791},
doi = {10.1587/TRANSINF.E94.D.1778},
}

@article{089cf86ff14953a2e38065c11fec31356f3f8b57,
title = {Rotalumè: A Tool for Automatic Reverse Engineering of Malware Emulators},
year = {2009},
url = {https://www.semanticscholar.org/paper/089cf86ff14953a2e38065c11fec31356f3f8b57},
abstract = {Malware authors have recently begun using emulation technology to obfuscate their code. They convert native malware binaries into bytecode programs written in a randomly generated instruction set and paired with a native binary emulator that interprets the bytecode. No existing malware analysis can reliably reverse this obfuscation technique. In this paper, we present the first work in automatic reverse engineering of malware emulators. Our algorithms are based on dynamic analysis. We execute the emulated malware in a protected environment and record the entire x86 instruction trace generated by the emulator. We then use dynamic data-flow and taint analysis over the trace to identify data buffers containing the bytecode program and extract the syntactic and semantic information about the bytecode instruction set. With these analysis outputs, we are able to generate data structures, such as control-flow graphs, that provide the foundation for subsequent malware analysis. We implemented a proofof-concept system called Rotalumè and evaluated it using both legitimate programs and malware emulated by VMProtect and Code Virtualizer. The results show that Rotalumè accurately reveals the syntax and semantics of emulated instruction sets and reconstructs execution paths of original programs from their bytecode representations.},
author = {Monirul I. Sharif and A. Lanzi and Jonathon T. Giffin and Wenke Lee},
}

@article{ed15712dbb0c9541de4b90c92a700ee5170ed78d,
title = {Efficient, sensitivity resistant binary instrumentation},
year = {2011},
url = {https://www.semanticscholar.org/paper/ed15712dbb0c9541de4b90c92a700ee5170ed78d},
abstract = {Binary instrumentation allows users to inject new code into programs without requiring source code, symbols, or debugging information. Instrumenting a binary requires structural modifications such as moving code, adding new code, and overwriting existing code; these modifications may unintentionally change the program's semantics. Binary instrumenters attempt to preserve the intended semantics of the program by further transforming the code to compensate for these structural modifications. Current instrumenters may fail to correctly preserve program semantics or impose significant unnecessary compensation cost because they lack a formal model of the impact of their structural modifications on program semantics. These weaknesses are particularly acute when instrumenting highly optimized or malicious code, making current instrumenters less useful as tools in the security or high-performance domains. We present a formal specification of how the structural modifications used by instrumentation affect a binary's visible behavior, and have adapted the Dyninst binary instrumenter to use this specification, thereby guaranteeing correct instrumentation while greatly reducing compensation costs. When compared against the fastest widely used instrumenters our technique imposed 46% less overhead; furthermore, we can successfully instrument highly defensive binaries that are specifically looking for code patching and instrumentation.},
author = {Andrew R. Bernat and Kevin A. Roundy and B. Miller},
doi = {10.1145/2001420.2001432},
}

@article{c3b6d310aea8328168c6f05e057031582f6da3c6,
title = {Automatic Static Unpacking of Malware Binaries},
year = {2009},
url = {https://www.semanticscholar.org/paper/c3b6d310aea8328168c6f05e057031582f6da3c6},
abstract = {Current malware is often transmitted in packed or encrypted form to prevent examination by anti-virus software.To analyze new malware, researchers typically resort to dynamic code analysis techniques to unpack the code for examination.Unfortunately, these dynamic techniques are susceptible to a variety of anti-monitoring defenses, as well as "time bombs" or "logic bombs," and can be slow and tedious to identify and disable. This paper discusses an alternative approach that relies on static analysis techniques to automate this process. Alias analysis can be used to identify the existence of unpacking,static slicing can identify the unpacking code, and control flow analysis can be used to identify and neutralize dynamic defenses. The identified unpacking code can be instrumented and transformed, then executed to perform the unpacking.We present a working prototype that can handle a variety of malware binaries, packed with both custom and commercial packers, and containing several examples of dynamic defenses.},
author = {Kevin Coogan and S. Debray and Tasneem Kaochar and Gregg M. Townsend},
journal = {2009 16th Working Conference on Reverse Engineering},
volume = {},
pages = {167-176},
doi = {10.1109/WCRE.2009.24},
}

@article{9cc006b53e0d9977a5644cc54d224c4893bebe04,
title = {Unpacking Techniques and Tools in Malware Analysis},
year = {2012},
url = {https://www.semanticscholar.org/paper/9cc006b53e0d9977a5644cc54d224c4893bebe04},
abstract = {Nowadays most of malware samples are packed with runtime packers to complicate the task of reverse engineering and security analysis in order to evade detection of signature-based anti-virus engines. In the overall process of malware analysis, unpacking a packed malicious binary effectively is a necessary preliminary to extract the structure features from the binary for generation of its signature, and therefore several unpacking techniques have been proposed so far that attempt to deal with the packer problem. This brief survey article provides an overview of the currently published prevalent unpacking techniques and tools. It covers the operation process of packing and unpacking, packer detection methods, heuristic policies for spotting original entry point (OEP), environments for runtime unpacking, anti-unpacking techniques, and introduces several typical tools for unpacking.},
author = {Peidai Xie and Meijian Li and Y. Wang and Jinghong Su and Xi Cheng Lu},
journal = {Applied Mechanics and Materials},
volume = {198-199},
pages = {343 - 350},
doi = {10.4028/www.scientific.net/AMM.198-199.343},
}

@article{0e2b066f53c72aa196fd6e521a40953124adeaec,
title = {Thwarting real-time dynamic unpacking},
year = {2011},
url = {https://www.semanticscholar.org/paper/0e2b066f53c72aa196fd6e521a40953124adeaec},
abstract = {Packing is a very popular technique for obfuscating programs, and malware in particular. In order to successfully detect packed malware, dynamic unpacking techniques have been proposed in literature. Dynamic unpackers execute and monitor a packed program, and try to guess when the original code of the program is available unprotected in memory. The major drawback of dynamic unpackers is the performance overhead they introduce. To reduce the overhead and make it possible to perform dynamic unpacking at end-hosts, researches have proposed real-time unpackers that operate at a coarser granularity, namely OmniUnpack and Justin. In this paper, we present a simple compile-time packing algorithm that maximizes the cost of unpacking and minimizes the amount of program code that can be automatically recovered by real-time coarse grained unpackers. The evaluation shows that the real-time dynamic unpackers are totally ineffective against this algorithm.},
author = {Leyla Bilge and A. Lanzi and D. Balzarotti},
doi = {10.1145/1972551.1972556},
}

@article{5c5437c45d0fc9fb947c2ce5c5b6959e7cf71d49,
title = {A Generic Approach to Automatic Deobfuscation of Executable Code},
year = {2015},
url = {https://www.semanticscholar.org/paper/5c5437c45d0fc9fb947c2ce5c5b6959e7cf71d49},
abstract = {Malicious software are usually obfuscated to avoid detection and resist analysis. When new malware is encountered, such obfuscations have to be penetrated or removed ("deobfuscated") in order to understand the internal logic of the code and devise countermeasures. This paper discusses a generic approach for deobfuscation of obfuscated executable code. Our approach does not make any assumptions about the nature of the obfuscations used, but instead uses semantics-preserving program transformations to simplify away obfuscation code. We have applied a prototype implementation of our ideas to a variety of different kinds of obfuscation, including emulation-based obfuscation, emulation-based obfuscation with runtime code unpacking, and return-oriented programming. Our experimental results are encouraging and suggest that this approach can be effective in extracting the internal logic from code obfuscated using a variety of obfuscation techniques, including tools such as Themida that previous approaches could not handle.},
author = {B. Yadegari and Brian Johannesmeyer and Ben Whitely and S. Debray},
journal = {2015 IEEE Symposium on Security and Privacy},
volume = {},
pages = {674-691},
doi = {10.1109/SP.2015.47},
}

@article{30e50e879b0de3ece433f46d0664e83266a8db2e,
title = {Measuring and Defeating Anti-Instrumentation-Equipped Malware},
year = {2017},
url = {https://www.semanticscholar.org/paper/30e50e879b0de3ece433f46d0664e83266a8db2e},
abstract = {Malware authors constantly develop new techniques in order to evade analysis systems. Previous works addressed attempts to evade analysis by means of anti-sandboxing and anti-virtualization techniques, for example proposing to run samples on bare-metal. However, state-of-the-art bare-metal tools fail to provide richness and completeness in the results of the analysis. In this context, Dynamic Binary Instrumentation (DBI) tools have become popular in the analysis of new malware samples because of the deep control they guarantee over the instrumented binary. As a consequence, malware authors developed new techniques, called anti-instrumentation, aimed at detecting if a sample is being instrumented. We propose a practical approach to make DBI frameworks more stealthy and resilient against anti-instrumentation attacks. We studied the common techniques used by malware to detect the presence of a DBI tool, and we proposed a set of countermeasures to address them. We implemented our approach in Arancino, on top of the Intel Pin framework. Armed with it, we perform the first large-scale measurement of the anti-instrumentation techniques employed by modern malware. Finally, we leveraged our tool to implement a generic unpacker, showing some case studies of the anti-instrumentation techniques used by known packers.},
author = {Mario Polino and Andrea Continella and Sebastiano Mariani and Stefano D'Alessio and Lorenzo Fontana and Fabio Gritti and S. Zanero},
doi = {10.1007/978-3-319-60876-1_4},
}

@article{828e55eeadd0ecf401cebb52d2fdec1e6c4ec9df,
title = {CodeXt: Automatic Extraction of Obfuscated Attack Code from Memory Dump},
year = {2014},
url = {https://www.semanticscholar.org/paper/828e55eeadd0ecf401cebb52d2fdec1e6c4ec9df},
abstract = {In this paper, we present CodeXt—a novel malware code extraction framework built upon selective symbolic execution (S2E). Upon real-time detection of the attack, CodeXt is able to automatically and accurately pinpoint the exact start and boundaries of the attack code even if it is mingled with random bytes in the memory dump. CodeXt has a generic way of handling self-modifying code and multiple layers of encoding, and it can automatically extract the complete hidden and transient code protected by multiple layers of sophisticated encoders without using any signature or pattern of the decoder. To the best of our knowledge, CodeXt is the first tool that can automatically extract code protected by Metasploit’s polymorphic xor additive feedback encoder Shikata-Ga-Nai, as well as transient code protected by multi-layer incremental encoding.},
author = {Ryan J. Farley and Xinyuan Wang},
doi = {10.1007/978-3-319-13257-0_32},
}

@article{ff25f2802ea8f79ba95629ab5aa53a8d9a3fd794,
title = {ABSTRACT, SAFE, TIMELY, AND EFFICIENT BINARY MODIFICATION},
year = {2012},
url = {https://www.semanticscholar.org/paper/ff25f2802ea8f79ba95629ab5aa53a8d9a3fd794},
abstract = {},
author = {Andrew R. Bernat},
}

@article{b25e0fe6739214ffd3d5f1ca5e651b57bd81aa50,
title = {Deep Analysis of Binary Code to Recover Program Structure},
year = {2014},
url = {https://www.semanticscholar.org/paper/b25e0fe6739214ffd3d5f1ca5e651b57bd81aa50},
abstract = {Title of dissertation: DEEP ANALYSIS OF BINARY CODE TO RECOVER PROGRAM STRUCTURE Khaled ElWazeer, Doctor of Philosophy, 2014 Dissertation directed by: Professor Rajeev Barua Department of Electrical and Computer Engineering Reverse engineering binary executable code is gaining more i nterest in the research community. Agencies as diverse as anti-virus companies, se curity consultants, code forensics consultants, law-enforcement agencies and nati onal security agencies routinely try to understand binary code. Engineers also often need to d ebug, optimize or instrument binary code during the software development process. In this dissertation, we present novel techniques to extend he capabilities of existing binary analysis and rewriting tools to be more scalab le, handling a larger set of stripped binaries with better and more understandable outp uts as well as ensuring correct recovered intermediate representation (IR) from binar ies such that any modified or rewritten binaries compiled from this representation work correctly. In the first part of the dissertation, we present techniques t o recover accurate function boundaries from stripped executables. Our techniques as opposed to current techniques ensure complete live executable code coverage, high quality recovered code, and functional behavior for most application binaries. We use s tatic and dynamic based techniques to remove as much spurious code as possible in a safe ma nner that does not hurt code coverage or IR correctness. Next, we present static tec hniques to recover correct prototypes for the recovered functions. The recovered prot otypes include the complete set of all arguments and returns. Our techniques ensure corr ct behavior of rewritten binaries for both internal and external functions. Finally, we present scalable and precise techniques to reco ver l cal variables for every function obtained as well as global and heap variables . Different techniques are represented for floating point stack allocated variables an d memory allocated variables. Data type recovery techniques are presented to declare mean ingful data types for the detected variables. Our data type recovery techniques can rec over integer, pointer, structural and recursive data types. We discuss the correctness of the r ecovered representation. The evaluation of all the methods proposed is conducted on Se condWrite, a binary rewriting framework developed by our research group. An imp ortant metric in the evaluation is to be able to recompile the IR with the recovered info rmation and run it producing the same answer that is produced when running the original ex ecutable. Another metric is the analysis time. Some other metrics are proposed to meas ure the quality of the IR with respect to the IR with source code information availabl e. DEEP ANALYSIS OF BINARY CODE TO RECOVER PROGRAM STRUCTURE},
author = {Khaled Elwazeer},
}

@article{29e8a39e5ea2ef726f80fbafd53a3277fce6a405,
title = {Deobfuscation of virtualization-obfuscated software: a semantics-based approach},
year = {2011},
url = {https://www.semanticscholar.org/paper/29e8a39e5ea2ef726f80fbafd53a3277fce6a405},
abstract = {When new malware are discovered, it is important for researchers to analyze and understand them as quickly as possible. This task has been made more difficult in recent years as researchers have seen an increasing use of virtualization-obfuscated malware code. These programs are difficult to comprehend and reverse engineer, since they are resistant to both static and dynamic analysis techniques. Current approaches to dealing with such code first reverse-engineer the byte code interpreter, then use this to work out the logic of the byte code program. This outside-in approach produces good results when the structure of the interpreter is known, but cannot be applied to all cases. This paper proposes a different approach to the problem that focuses on identifying instructions that affect the observable behavior of the obfuscated code. This inside-out approach requires fewer assumptions, and aims to complement existing techniques by broadening the domain of obfuscated programs eligible for automated analysis. Results from a prototype tool on real-world malicious code are encouraging.},
author = {Kevin Coogan and Gen Lu and S. Debray},
doi = {10.1145/2046707.2046739},
}
